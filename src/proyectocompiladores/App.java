/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyectocompiladores;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import java_cup.runtime.Symbol;
import javax.swing.BorderFactory;

import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.filechooser.FileNameExtensionFilter;
import org.graphstream.graph.Graph;
import org.graphstream.graph.Node;
import org.graphstream.graph.implementations.SingleGraph;
import org.graphstream.ui.swingViewer.ViewPanel;
import org.graphstream.ui.view.Viewer;

/**
 *
 * @author Maslz
 */
public class App extends javax.swing.JFrame {

    // Variables globales
    PrintWriter writer;
    Process powerShellProcess;
    String path = ".\\src\\FlexAndCup\\";
    String[] pathSyntax = { "-parser", "Syntax", path + "Syntax.cup" };

    static int CantTemporales = 1;

    static TableQuad TablaCuadruplos = new TableQuad();
    static TablaMensajes tablamensajes = new TablaMensajes();

    /**
     * Creates new form App
     */
    public App() {

        initComponents();
        this.setLocationRelativeTo(null);
        this.ta_result.setBackground(Color.BLACK);
        this.ta_result.setForeground(Color.WHITE);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated
    // Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        ta_code = new javax.swing.JTextArea();
        jb_clear = new javax.swing.JButton();
        jb_save = new javax.swing.JButton();
        jb_load = new javax.swing.JButton();
        jb_compile = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        ta_result = new javax.swing.JTextArea();
        jLabel2 = new javax.swing.JLabel();
        jb_save_as = new javax.swing.JButton();
        jb_RUN = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setBackground(new java.awt.Color(0, 0, 0));
        setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        setResizable(false);
        setSize(new java.awt.Dimension(1280, 720));

        ta_code.setColumns(20);
        ta_code.setRows(5);
        jScrollPane1.setViewportView(ta_code);

        jb_clear.setText("Clear");
        jb_clear.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jb_clearActionPerformed(evt);
            }
        });

        jb_save.setText("Save");
        jb_save.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jb_saveActionPerformed(evt);
            }
        });

        jb_load.setText("Load");
        jb_load.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jb_loadActionPerformed(evt);
            }
        });

        jb_compile.setText("Generate");
        jb_compile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jb_compileActionPerformed(evt);
            }
        });

        jLabel1.setText("Your Code:");

        ta_result.setEditable(false);
        ta_result.setColumns(20);
        ta_result.setRows(5);
        jScrollPane2.setViewportView(ta_result);

        jLabel2.setText("Output:");

        jb_save_as.setText("Save as..");
        jb_save_as.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jb_save_asActionPerformed(evt);
            }
        });

        jb_RUN.setText("RUN");
        jb_RUN.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jb_RUNActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout
                .createSequentialGroup().addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout
                        .createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 688, Short.MAX_VALUE)
                                .addComponent(jScrollPane1)
                                .addComponent(jLabel1, javax.swing.GroupLayout.Alignment.LEADING))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addGroup(layout.createSequentialGroup().addComponent(jb_clear)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED,
                                                javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                        .addComponent(jb_load))
                                .addComponent(jb_save_as).addComponent(jb_save)
                                .addComponent(jb_compile, javax.swing.GroupLayout.Alignment.TRAILING,
                                        javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE,
                                        Short.MAX_VALUE)
                                .addComponent(jb_RUN, javax.swing.GroupLayout.Alignment.TRAILING,
                                        javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE,
                                        Short.MAX_VALUE)))
                        .addComponent(jLabel2))
                .addContainerGap(14, Short.MAX_VALUE)));
        layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout
                .createSequentialGroup().addContainerGap().addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addGroup(layout
                        .createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(jb_clear).addComponent(jb_load))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent(jb_save)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent(jb_save_as)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED,
                                javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jb_compile)).addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE,
                                479, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 13, Short.MAX_VALUE)
                .addComponent(jLabel2).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(
                        layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 182,
                                        javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(jb_RUN))
                .addContainerGap()));

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jb_saveActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jb_saveActionPerformed

        if (this.input_C == null) {
            this.saveNewFile();

        } else if (input_C.exists()) {
            FileWriter fr = null;
            try {
                fr = new FileWriter(input_C);
                fr.write(this.ta_code.getText());
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                try {
                    fr.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }// GEN-LAST:event_jb_saveActionPerformed

    private void jb_clearActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jb_clearActionPerformed
        clear();
        this.input_C = null;
    }// GEN-LAST:event_jb_clearActionPerformed

    private void jb_compileActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jb_compileActionPerformed
        try {
            // TODO add your handling code here:
            generate();

        } catch (Exception ex) {
            Logger.getLogger(App.class.getName()).log(Level.SEVERE, null, ex);
        }

    }// GEN-LAST:event_jb_compileActionPerformed

    private void jb_loadActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jb_loadActionPerformed
        clear();
        JFileChooser jfc = new JFileChooser("./Test Files/");
        FileNameExtensionFilter filter = new FileNameExtensionFilter("C files.", "c");
        jfc.setFileFilter(filter);
        int result = jfc.showOpenDialog(this);
        if (result == JFileChooser.APPROVE_OPTION) {
            this.input_C = jfc.getSelectedFile();
            try {
                this.ta_code.setText(this.getCFileText(input_C));
            } catch (IOException ex) {
                Logger.getLogger(App.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }// GEN-LAST:event_jb_loadActionPerformed

    private void jb_save_asActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jb_save_asActionPerformed
        this.saveNewFile();
    }// GEN-LAST:event_jb_save_asActionPerformed

    private void jb_RUNActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jb_RUNActionPerformed
        System.setProperty("org.graphstream.ui.renderer", "org.graphstream.ui.j2dviewer.J2DGraphRenderer");
        errores = "";
        if (ta_code.getText() != null) {
            try {
                parser p = new parser(new Lexer(new StringReader(ta_code.getText())));
                Object x = p.parse().value;

                // System.out.println(x.toString());
                MiArbolito myTree = (MiArbolito) x;
                // Compi II

                myTree.reduce();
                globalVariables = new Table();
                Table table = new Table();

                System.out.println("Este es el primer nodo del arbol: " + myTree.getValue().value);
                semantico(myTree, table);
                System.out.println("Print table main");
                table.print();

                // intermedio

                Values v = myTree.printAndFill();

                Graph graph = new SingleGraph("AST");

                ArrayList<String> resultado = p.errors;
                // String errores = "";

                for (String error : resultado) {
                    errores += error + "\n";
                }

                if (errores.isEmpty()) {
                    this.ta_result.setForeground(Color.GREEN);
                    this.ta_result.setText("¡Analisis lexico y sintactico exitoso!");
                } else {
                    this.ta_result.setForeground(Color.RED);
                    this.ta_result.setText(errores);

                }
                // graph.addNode("");
                int initialPositionX = 0;
                int initialPositionY = 0;

                for (int i = 0; i < v.list.size(); i++) {
                    String sub1, sub2, sub3;
                    sub1 = myTree.graphList.get(i)[0];
                    sub2 = myTree.graphList.get(i)[1];
                    sub3 = myTree.graphList.get(i)[2];
                    /*
                     * System.out.println("Main graphList Element 1: " +
                     * myTree.graphList.get(i)[0]); System.out.println("Main graphList Element 2: "
                     * + myTree.graphList.get(i)[1]);
                     * System.out.println("Main graphList Element 2: " +
                     * myTree.graphList.get(i)[1]);
                     */
                    graph.addNode(sub1).addAttribute("ui.label", sub3/* , */);
                    if (sub1 == "translation_unit") {
                        Node node = graph.getNode(sub1);
                        node.addAttribute("ui.class", "F");
                        node.addAttribute("layout.frozen");
                        node.addAttribute("x", 0.0);
                        node.addAttribute("y", 0.0);

                        node.addAttribute("ui.style", "fill-color: rgb(255,0,0);" + "size: 40px, 40px;");

                    } else {
                        Node node = graph.getNode(sub1);
                        node.addAttribute("ui.class", "N");

                        // node.addAttribute("ui.style", "fill-color: rgb(255,255,0);");
                        // graph.getNode(sub1).addAttribute("ui.style", "fill-mode: none;");
                        // graph.getNode(sub1).addAttribute("ui.style", "text-align: center;");
                    }

                    // graph.getNode(sub1).addAttribute("ui.style", "text-alignment: center;");
                    // initialPositionY += 20;
                    // initialPositionX += 20;
                    // graph.addNode(sub1).addAttribute("ui.label", "Name: " + sub1 + " Parent: " +
                    // sub2);
                }
                System.out.println(v.tree);
                System.out.println("length " + myTree.graphList.size());

                for (int i = 0; i < v.list.size(); i++) {
                    String sub1, sub2;
                    sub1 = myTree.graphList.get(i)[0];
                    sub2 = myTree.graphList.get(i)[1];

                    if (sub1.equals("translation_unit") && sub2.equals("")) {
                        // System.out.println("translation_unit");
                    } else {
                        graph.addEdge(sub2 + " " + sub1, sub2, sub1).addAttribute("layout.weight", 4, pathSyntax);

                    }
                }

                graph.addAttribute("ui.stylesheet", "graph { fill-color: #bc572f; " + "fill-mode: gradient-vertical;}"
                        + "node { text-color: white;" + "text-size: 18px;" + "size: 30px, 30px;" + "shape: circle; "
                        + "fill-color: red, orange;" + "    fill-mode: gradient-vertical;" + "    stroke-mode: plain;"
                        + "    stroke-color: black;" + "    stroke-width: 5px; }" + "edge { fill-color: #d19214;"
                        + "    size: 2px;  } " + "node:clicked { fill-color: rgb(0,0,255); } ");

                graph.setAttribute("ui.antialias");
                graph.setAttribute("ui.quality");

                // viewer.disableAutoLayout();
                // graph.display().disableAutoLayout();
                // myTree.printGraph();
                /*
                 * Viewer viewer = graph.display();
                 * 
                 * viewer.setCloseFramePolicy(Viewer.CloseFramePolicy.HIDE_ONLY);
                 */
                JFrame frame = new JFrame("GRAPH");
                @SuppressWarnings("serial")
                JPanel panel = new JPanel(new GridLayout()) {
                    @Override
                    public Dimension getPreferredSize() {
                        return new Dimension(640, 480);
                    }
                };
                panel.setBorder(BorderFactory.createLineBorder(Color.blue, 5));
                Viewer viewer = new Viewer(graph, Viewer.ThreadingModel.GRAPH_IN_GUI_THREAD);
                ViewPanel viewPanel = viewer.addDefaultView(false);
                viewer.enableAutoLayout();
                viewPanel.getCamera().setViewPercent(0.25);
                viewPanel.getCamera().setViewCenter(0, 0, 0);
                viewPanel.requestFocusInWindow();
                panel.add(viewPanel);
                frame.add(panel);
                frame.pack();
                frame.setLocationRelativeTo(null);
                JOptionPane.showMessageDialog(this,
                        "Para navegar el arbol utilize las teclas direccionales, Page UP y Page Down para hacer Zoom");
                frame.setVisible(true);

                table.print();

                // System.out.println("AntesIntermedio");

                myTree = (MiArbolito) x;
                table = new Table();

                Intermedio(myTree, table);

                // System.out.println("DespueIntermedio");

                TablaCuadruplos.imprimirTablaCuadruplo();
                System.out.println("\n");
                tablamensajes.imprimirTablaMensajes();

                // resetear tabla y temps
                TablaCuadruplos.resetearTabla();
                tablamensajes.resetearTabla();
                CantTemporales = 1;

                // END Compi II

            } catch (FileNotFoundException ex) {

                Logger.getLogger(App.class.getName()).log(Level.SEVERE, null, ex);
            } catch (Exception ex) {
                // Logger.getLogger(App.class.getName()).log(Level.SEVERE, null, ex);
            }

            System.out.println();

        }

    }// GEN-LAST:event_jb_RUNActionPerformed

    public static void generate() throws IOException, Exception {
        generateLexer();
        generateParser();
    }

    String getCFileText(File file) throws FileNotFoundException, IOException {
        BufferedReader br = new BufferedReader(new FileReader(file));
        String st;
        String out = "";
        while ((st = br.readLine()) != null) {
            System.out.println(st);
            out += st + "\n";
        }
        br.close();
        return out;
    }

    void clear() {
        this.ta_result.setText("");
        this.ta_code.setText("");
    }

    void saveNewFile() {
        JFileChooser jfc = new JFileChooser("./Test Files/");
        FileNameExtensionFilter filter = new FileNameExtensionFilter("C files.", "c");
        jfc.setFileFilter(filter);
        int option = jfc.showSaveDialog(this);
        if (option == JFileChooser.APPROVE_OPTION) {
            String new_file_path = jfc.getSelectedFile().getAbsolutePath();
            if (!new_file_path.endsWith(".c")) {
                new_file_path += ".c";
            }
            input_C = new File(new_file_path);
            FileWriter fr = null;
            try {
                fr = new FileWriter(input_C);
                fr.write(this.ta_code.getText());
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                try {
                    fr.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static void generateLexer() {
        String parametros[] = { "-d", "src/proyectocompiladores/", "src/proyectocompiladores/newLexer.flex" };
        try {
            jflex.Main.generate(parametros);
        } catch (Exception e) {
            System.out.println(e);
        }

    }

    public static void generateParser() {
        String parametros[] = { "-destdir", "src/proyectocompiladores/", "-parser", "parser",
                "src/proyectocompiladores/parser.cup" };
        try {
            java_cup.Main.main(parametros);
        } catch (Exception e) {
            System.out.println(e);
        }
    }

    // COMPI II
    public static void semantico(MiArbolito parent_node, Table table) {

        ArrayList<MiArbolito> childs = parent_node.getChildren();
        for (MiArbolito child : childs) {
            if (child.getValue().value.toString().equals("declaration")
                    || child.getValue().value.equals("parameter_declaration")) {
                String type = child.getChildren().get(0).getValue().value.toString();
                System.out.println("type var: " + type);
                if (parent_node.valueIsString("iteration_statement")) {

                    Table child_table = new Table(table);
                    table.addChild(child_table);
                    getDeclarations(child.getChildren().get(1), type, child_table);
                } else {
                    getDeclarations(child.getChildren().get(1), type, table);
                }
            } else if (child.getValue().value.equals("=")) {

                System.out.println("Hijos en Child: " + child.getChildren().size());

                Asignacion(child, table);

            } else if (child.getValue().value.equals("function_definition")) {
                ArrayList<String> parameters = new ArrayList();

                Table child_table = new Table(table);
                funcType = child.getChildren().get(0).getValue().value.toString();
                if (child.getChildren().get(1).getValue().value.toString().equals("direct_declarator")) {
                    System.out.println("Entre al if del direct_declarator");
                    if (child.getChildren().get(1).getChildren().get(0).getValue().value.toString().equals("function_declarator")) {

                        funName = child.getChildren().get(1).getChildren().get(1).getValue().value.toString();
                        System.out.println("FunName: " + funName);

                        //ESTO SE TIENE QUE HACER CON RECURSION PORQUE SI HAY MUCHOS PARAMETROS, NO SE GUARDAN TODOS
                        try {
                            if (child.getChildren().get(1).getChildren().get(2).getValue().value.toString().equals("parameter_list")) {
                                System.out.println("parameter_list if");
                                ArrayList<MiArbolito> paramChild = new ArrayList();
                                paramChild = child.getChildren().get(1).getChildren().get(2).getChildren();
                                System.out.println("param Child 0: " + paramChild.get(0).getValue().value.toString());
                                if (paramChild.get(0).getValue().value.equals("parameter_list")) {
                                    System.out.println("if paramChild");
                                    ArrayList<MiArbolito> paramChild2 = paramChild.get(0).getChildren();
                                    for (MiArbolito params : paramChild2) {
                                        System.out.println("for paramsChild2: " + params.getValue().value.toString());
                                        if (params.getValue().value.equals("parameter_declaration")) {
                                            System.out.println("parameter_declaration if");
                                            String getParameter = params.getChildren().get(0).getValue().value.toString();
                                            System.out.println("Parameter paramChild2: " + getParameter);
                                            parameters.add(getParameter);

                                        }
                                    }
                                }

                                System.out.println("paramlist Children: " + paramChild.toString());
                                for (MiArbolito params : paramChild) {
                                    System.out.println("En el for: " + params.getValue().value.toString());
                                    if (params.getValue().value.equals("parameter_declaration")) {
                                        System.out.println("parameter_declaration if");
                                        String getParameter = params.getChildren().get(0).getValue().value.toString();
                                        System.out.println("Parameter: " + getParameter);
                                        parameters.add(getParameter);

                                    }
                                }
                            }
                            if (child.getChildren().get(1).getChildren().get(2).getValue().value.toString().equals("parameter_declaration")) {
                                System.out.println("Solo uno parameter_declaration if");
                                String getParameter = child.getChildren().get(1).getChildren().get(2).getChildren().get(0).getValue().value.toString();
                                System.out.println("Parameter: " + getParameter);
                                parameters.add(getParameter);

                            }
                        } catch (Exception e) {
                            System.err.println(e);
                        }
                        System.out.println("parameters array: " + parameters.toString());
                        if (!funName.equals("main")) {
                            if (!parameters.isEmpty()) {
                                StringBuilder concatParams = new StringBuilder();
                                for (int i = 0; i < parameters.size(); i++) {
                                    System.out.println("i: " + i + " parameters size: " + parameters.size());
                                    if ((i + 1) != parameters.size()) {
                                        concatParams.append(parameters.get(i) + " x ");

                                    } else {
                                        System.err.println("no x");
                                        concatParams.append(parameters.get(i));
                                    }

                                }

                                System.out.println("concatParams: " + concatParams.toString());
                                concatParams.append(" -> " + funcType);

                                table.addTableRow(child.getChildren().get(1).getChildren().get(1).getValue().value.toString(),
                                        null, concatParams.toString(), 0);

                            } else {
                                table.addTableRow(child.getChildren().get(1).getChildren().get(1).getValue().value.toString(),
                                        null, "void -> " + funcType, 0);

                            }
                        }
                    }
                }
                System.out.println("FuncType: " + funcType);

                table.addChild(child_table);
                ArrayList<MiArbolito> function_definition_childs = child.getChildren();
                for (MiArbolito function_child : function_definition_childs) {
                    semantico(function_child, child_table);
                }
            } else if (child.getValue().value.equals("decl_stmnt_list")
                    && !parent_node.getValue().value.equals("function_definition")) {

                Table child_table = new Table(table);
                table.addChild(child_table);
                semantico(child, child_table);
            } else {
                semantico(child, table);
            }
        }
    }

    public static void Asignacion(MiArbolito node, Table table) {

        //Esto sirve para hacer x = b
        boolean funCall = false;
        if (node.getChildren().size() == 2) {
            MiArbolito first = node.getChildren().get(0);
            MiArbolito second = node.getChildren().get(1);
            if (first.getValue().sym == sym.IDENTIFIER) {
                TableRow firstResult = table.search(first.getValue().value.toString());
                if (firstResult != null) {
                    if (second.getValue().value.equals("unary_expression")) {
                        if (second.getChildren().get(0).getValue().sym == 71) { //Address de memoria
                            if (!firstResult.type.contains("Pointer")) {
                                String error = "Error en la linea " + (first.getValue().right + 1) + ", columna "
                                        + first.getValue().left + " en el token " + first.getValue().value
                                        + ": Varibales son de diferente tipo\n";
                                System.err.println(error);
                                errores += error;
                            }
                        }
                    } else if (second.getValue().value.equals("postfix_expression")) {

                        try {
                            System.out.println("-----------------Table en asignacion------------------");
                            table.print();
                            System.out.println("Parent de la table");
                            table.parent.print();
                            System.out.println("------------------------------------------------------");
                            String currentFun = second.getChildren().get(1).getValue().value.toString();
                            System.out.println("second child, buscando la funcion: " + currentFun);
                            TableRow functionResult = table.search(currentFun);
                            if (functionResult != null) {
                                System.out.println("Function Result: " + functionResult.id);

                                if (functionResult.type.contains("void -> ")) {
                                    System.out.println("CONTAINS VOID");
                                } else {

                                    String separator = " -> ";
                                    int sepPos = functionResult.type.indexOf(separator);
                                    if (sepPos == -1) {
                                        System.out.println("");
                                    }
                                    String funcType = functionResult.type.substring(sepPos + separator.length());
                                    System.out.println("Substring after separator = " + funcType);

                                    String getParameters = functionResult.type.substring(0, sepPos);
                                    String[] parameters;
                                    parameters = getParameters.split(" x ");
                                    System.out.println("Parameters");
                                    for (int i = 0; i < parameters.length; i++) {
                                        System.out.println(parameters[i]);
                                    }

                                    if (second.getChildren().get(2).getValue().value.toString().equals("expression")) {
                                        ArrayList<String> recursiveParams = new ArrayList();

                                        Values v = getAsignationParams(second.getChildren().get(2), recursiveParams, parameters, 0, 0);

                                        recursiveParams = v.parameters;
                                        recursiveParams.toString();

                                        if (v.errors > 0) {
                                            String error = "Error en la linea " + (second.getValue().right + 1) + ", columna " + second.getValue().left + " en el token " + second.getValue().value + ": Los parametros de la funcion no son correctos\n";
                                            System.err.println(error);
                                            errores += error;
                                        }

                                    }

                                }

                                if (!firstResult.type.equals(funcType)) {
                                    String error = "Error en la linea " + (second.getValue().right + 1) + ", columna " + second.getValue().left + " en el token " + second.getValue().value + ": La funcion es de diferente tipo\n";
                                    System.err.println(error);
                                    errores += error;
                                }

                            } else {
                                String error = "Error en la linea " + (second.getValue().right + 1) + ", columna " + second.getValue().left + " en el token " + second.getValue().value + ": La funcion no existe\n";
                                System.err.println(error);
                                errores += error;
                            }

                            funCall = true;
                        } catch (Exception e) {
                        }

                    }
                    switch (second.getValue().sym) {
                        case sym.IDENTIFIER:
                            TableRow secondResult = table.search(second.getValue().value.toString());
                            if (secondResult != null) {
                                // Aquí le asigna a x el valor de b, virificando si son del mismo tipo
                                if (firstResult.type.equals(secondResult.type)) {
                                    firstResult.value = secondResult.value;
                                } else {
                                    // La segunda variable no es del mismo tipo
                                    String error = "Error en la linea " + (first.getValue().right + 1) + ", columna "
                                            + first.getValue().left + " en el token " + first.getValue().value
                                            + ": Varibales son de diferente tipo\n";
                                    System.err.println(error);
                                    errores += error;
                                }
                            } else {
                                // La segunda variable no existe
                                String error = "Error en la linea " + (second.getValue().right + 1) + ", columna "
                                        + second.getValue().left + " en el token " + second.getValue().value
                                        + ": Variable no ha sido declarada\n";
                                System.err.println(error);
                                errores += error;
                            }
                            break;
                        case sym.CONSTANT:
                        case sym.STRING_LITERAL:
                        case -1:
                            if (funCall == false) {
                                if (second.getChildren().size() > 0 && second.getChildren().get(0).getValue().sym == 71) {

                                } else if (checkValueType(second, firstResult.type)) {
                                    firstResult.value = second.getValue().value;
                                } else if (second.getChildren().size() > 0 && second.getChildren().get(0).getValue().sym != 71 || second.getChildren().size() == 0) {
                                    String error = "Error en la linea " + (first.getValue().right + 1) + ", columna " + first.getValue().left + " en el token " + first.getValue().value + ": Varibales son de diferente tipo\n";
                                    System.err.println(error);
                                    errores += error;
                                }
                            }
                            funCall = false;
                            break;
                        case sym.PLUS:
                        case sym.MINUS:
                        case sym.DIVIDE:
                        case sym.MUL:
                            if (firstResult.type.equals("int") || firstResult.type.equals("char")
                                    || firstResult.type.equals("double") || firstResult.type.equals("float")
                                    || firstResult.type.equals("long")) {
                                System.out.println("First Result: " + firstResult.id);
                                System.out.println("Node at this point: " + node.getValue().value);
                                aritmetica(node, firstResult.type, table);
                            } else {
                                String error = "Error en la linea " + (first.getValue().right + 1) + ", columna "
                                        + first.getValue().left + " en el token " + first.getValue().value
                                        + ": No se puede asignar expresion aritmetica\n";
                                System.err.println(error);
                                errores += error;
                            }
                            break;
                    }

                } else {
                    String error = "Error en la linea " + (first.getValue().right + 1) + ", columna "
                            + first.getValue().left + " en el token " + first.getValue().value
                            + ": Variable no ha sido declarada\n";
                    System.err.println(error);
                    errores += error;
                }
            } else if (first.getValue().sym == -1 && !first.valueIsString("ERROR")) {
                System.err.println(first.getValue().value);
                MiArbolito firstchild = first.getChildren().get(0);
                if (firstchild.getValue().sym == -1) {
                    MiArbolito secondchild = first.getChildren().get(1);
                    TableRow firstResult = table.search(secondchild.getValue().value.toString());
                    if (firstResult != null) {
                        MiArbolito thirdchild = first.getChildren().get(2);
                        String properties[] = arrayParse(firstResult);
                        String sizeOfArray = properties[0];
                        String type = properties[1];
                        if (Integer.parseInt(sizeOfArray) - 1 >= Integer
                                .parseInt(thirdchild.getValue().value.toString())) {

                            switch (second.getValue().sym) {
                                case sym.CONSTANT:
                                    if (type.equals("int") || firstResult.type.equals("char")
                                            || firstResult.type.equals("double") || firstResult.type.equals("float")
                                            || firstResult.type.equals("long")) {
                                        setValidNumber(second.getValue().value.toString(), second, type, false);
                                    } else {
                                        String error = "Error en la linea " + (thirdchild.getValue().right + 1)
                                                + ", columna " + thirdchild.getValue().left + " en el token "
                                                + thirdchild.getValue().value + ": Asignacion no es del tipo " + type
                                                + "\n";
                                        System.err.println(error);
                                        errores += error;
                                    }
                                    break;
                                case sym.STRING_LITERAL:
                                    if (type.contains("Pointer")) {
                                        setValidNumber(second.getValue().value.toString(), second, type, false);
                                    } else {
                                        String error = "Error en la linea " + (thirdchild.getValue().right + 1)
                                                + ", columna " + thirdchild.getValue().left + " en el token "
                                                + thirdchild.getValue().value + ": Asignacion no es del tipo " + type
                                                + "\n";
                                        System.err.println(error);
                                        errores += error;
                                    }
                                    break;
                            }
                        } else {
                            String error = "Error en la linea " + (thirdchild.getValue().right + 1) + ", columna "
                                    + thirdchild.getValue().left + " en el token " + thirdchild.getValue().value
                                    + ": Asignacion del arreglo fuera del limite\n";
                            System.err.println(error);
                            errores += error;
                        }

                    }

                }
            }
        }
    }

    public static Values getAsignationParams(MiArbolito node, ArrayList list, String[] parameters, int index, int errors) {
        MiArbolito firstChild = node.getChildren().get(0);
        if (firstChild.getValue().value.toString().equals("expression")) {
            list.add(node.getChildren().get(1).getValue().value.toString());
            System.out.println("Param value: " + node.getChildren().get(1).getValue().value.toString());
            if (!checkValueType(node.getChildren().get(1), parameters[index])) {
                System.out.println("Check value types parameters index: " + index);
                errors++;
            }

            getAsignationParams(firstChild, list, parameters, index++, errors);
        } else {
            try {
                System.out.println("Param value: " + firstChild.getValue().value.toString());

                if (!checkValueType(firstChild, parameters[index])) {
                    System.out.println("Check value types parameters last 1 index: " + index);
                    errors++;
                } else {
                    list.add(firstChild.getValue().value.toString());

                }
                index++;
                
                System.out.println("Param value: " + node.getChildren().get(1).getValue().value.toString());
                /*aqui esta pasando el numero como que fuera char, y no deberia pasar
                      obtener el tipo que viene con el valor
                    */
                if (!checkValueType(node.getChildren().get(1), parameters[index])) {
                    System.out.println("Check value types parameters last 2 index: " + index);
                    errors++;
                } else {
                    list.add(node.getChildren().get(1).getValue().value.toString());

                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        if (!(list.size() == parameters.length)) {
            errors++;
        }

        Values v = new Values(list, errors);
        return v;
    }

    public static void getDeclarations(MiArbolito node, String type, Table table) {
        String id = node.getValue().value.toString();
        ArrayList<MiArbolito> node_childs = node.getChildren();
        MiArbolito child_id, child_value;
        switch (id) {
            case "declaration_list":
                break;
            case "parameter_list":
            case "init_declarator_list":
                for (MiArbolito child : node_childs) {
                    getDeclarations(child, type, table);
                }
                break;
            case "init_declarator":
                child_id = node_childs.get(0);
                child_value = node_childs.get(1);
                if (child_id.getValue().value.equals("declarator")) {
                    child_id = child_id.getChildren().get(1);
                    if (checkValueType(child_value, "Pointer(" + type + ")")) {
                        int offset = table.getActualOffset();

                        Values v = table.addTableRow(child_id.getValue().value.toString(), child_value.getValue().value,
                                "Pointer(" + type + ")", offset);
                        if (v.addReturn == false) {
                            errores += v.message;
                        }
                    } else {
                        String error = "Error en linea " + (child_id.getValue().right + 1) + ", columna "
                                + child_id.getValue().left + " en el token " + child_id.getValue().value
                                + ", asignacion no es de tipo " + type + "*\n";
                        System.err.println(error);
                        errores += error;
                    }
                } else if (child_id.getValue().value.equals("direct_declarator")
                        && child_id.getChildren().get(0).getValue().value == "array_declarator") {
                    int offset = table.getActualOffset();

                    if (child_id.getChildren().size() == 3) {
                        if (child_id.getChildren().get(2).getValue().sym == sym.CONSTANT) {
                            if (setValidNumber(child_id.getChildren().get(2).getValue().value.toString(),
                                    child_id.getChildren().get(2), "int", false)) {
                                Values v = table.addTableRow(child_id.getChildren().get(1).getValue().value.toString(),
                                        null,
                                        "array(" + child_id.getChildren().get(2).getValue().value + ", " + type + ")",
                                        offset);
                                if (v.addReturn == false) {
                                    errores += v.message;
                                }
                            }

                        } else {
                            String error = "Error en linea " + (child_id.getChildren().get(1).getValue().right + 1)
                                    + ", columna " + child_id.getChildren().get(1).getValue().left + " en el token "
                                    + child_id.getChildren().get(1).getValue().value
                                    + ": asignacion no es de tipo arreglo " + type + "\n";
                            System.err.println(error);
                            errores += error;
                        }
                    } else if (child_id.getChildren().size() == 2) {
                        Values v = table.addTableRow(child_id.getChildren().get(1).getValue().value.toString(), null,
                                "array(0, " + type + ")", offset);
                        if (v.addReturn == false) {
                            errores += v.message;
                        }
                    }

                    System.err.println("Advertencia en la linea " + (child_id.getChildren().get(1).getValue().right + 1)
                            + ", columna " + child_id.getChildren().get(1).getValue().left + " en el token "
                            + child_id.getChildren().get(1).getValue().value
                            + ": no se acepta incializacion de arreglos");
                } else if (checkValueType(child_value, type)) {
                    int offset = table.getActualOffset();
                    if (child_value.getValue().sym != sym.PLUS && child_value.getValue().sym != sym.MUL
                            && child_value.getValue().sym != sym.DIVIDE && child_value.getValue().sym != sym.MINUS) {
                        Values v = table.addTableRow(child_id.getValue().value.toString(), child_value.getValue().value,
                                type, offset);
                        if (v.addReturn == false) {
                            errores += v.message;
                        }
                    } else {
                        Values v = table.addTableRow(child_id.getValue().value.toString(), null, type, offset);
                        if (v.addReturn == false) {
                            errores += v.message;
                        }
                    }
                } else {
                    String error = "Error en linea " + (child_id.getValue().right + 1) + ", columna "
                            + child_id.getValue().left + " en el token " + child_id.getValue().value
                            + ": asignacion no es de tipo " + type + "\n";
                    System.err.println(error);
                    errores += error;
                }
                break;
            case "direct_declarator": {
                String declaration_type = node_childs.get(0).getValue().value.toString();
                if (declaration_type.equals("function_declarator")) {
                    child_id = node_childs.get(1);
                    String parameter_types = "";
                    if (node_childs.size() > 2) {
                        parameter_types = node_childs.get(2).getValue().value.toString();
                        if (parameter_types.equals("parameter_list")) {
                            ArrayList<String> params = new ArrayList();
                            ArrayList<MiArbolito> param_childs = node_childs.get(2).getChildren();
                            for (MiArbolito param : param_childs) {
                                params.add(param.getValue().value.toString());
                            }
                            parameter_types = String.join(" x ", params);
                        }
                    }
                    parameter_types = type + " -> " + parameter_types;
                    int offset = table.getActualOffset();
                    Values v = table.addTableRow(child_id.getValue().value.toString(), null, parameter_types, offset);
                    if (v.addReturn == false) {
                        errores += v.message;
                    }
                } else if (declaration_type.equals("array_declarator")) {
                    child_id = node_childs.get(1);
                    int offset = table.getActualOffset();
                    if (node_childs.size() == 3) {
                        child_value = node_childs.get(2);
                        if (child_value.getValue().sym == 3) {
                            if (setValidNumber(child_value.getValue().value.toString(), child_value, "int", false)) {
                                Values v = table.addTableRow(child_id.getValue().value.toString(), null,
                                        "array(" + child_value.getValue().value + ", " + type + ")", offset);
                                if (v.addReturn == false) {
                                    errores += v.message;
                                }
                            }
                        } else {
                            String error = "Error en linea " + (child_id.getValue().right + 1) + ", columna "
                                    + child_id.getValue().left + " en el token " + child_id.getValue().value
                                    + ": asignacion no es de tipo arreglo " + type + "\n";
                            System.err.println(error);
                            errores += error;
                        }
                    } else {
                        Values v = table.addTableRow(child_id.getValue().value.toString(), null,
                                "array(0, " + type + ")", offset);
                        if (v.addReturn == false) {
                            errores += v.message;
                        }
                    }
                }
                break;
            }
            case "declarator":
                child_id = node_childs.get(1);
                int offset = table.getActualOffset();
                Values v = table.addTableRow(child_id.getValue().value.toString(), null, "Pointer(" + type + ")",
                        offset);
                if (v.addReturn == false) {
                    errores += v.message;
                }
                break;
            case "parameter_declaration":
                type = node_childs.get(0).getValue().value.toString();
                child_id = node_childs.get(1);
                getDeclarations(child_id, type, table);
                break;

            default:
                offset = table.getActualOffset();
                Values v1 = table.addTableRow(id, null, type, offset);
                if (v1.addReturn == false) {
                    errores += v1.message;
                }
        }
        // System.out.println("Print table");
        // table.print();
    }

    public static boolean checkValueType(MiArbolito node, String type) {
        Symbol value = node.getValue();

        switch (type) {
            case "int":
            case "short":
            case "long":
            case "float":
            case "double":
            case "char":
                if (value.sym == 3) {
                    return setValidNumber(value.value.toString(), node, type, false);
                } else if (value.value.toString().equals("unary_expression")) {
                    return setValidNumber(node.getChildren().get(1).getValue().value.toString(), node, type, true);
                } else if (value.sym >= 74 && value.sym <= 77) {
                    aritmetica(node, type, new Table());
                    return true;
                }
                break;
            case "Pointer(char)":
                return value.sym == 4;
        }
        return false;
    }

    public static void aritmetica(MiArbolito node, String type, Table table) {
        System.out.println("Aritmetica, Node: " + node.getValue().value + ", type: " + type);
        int symbol = node.getValue().sym;

        if (node.getChildren().size() == 2) {

            int firstChild = node.getChildren().get(0).getValue().sym;
            MiArbolito fChild = node.getChildren().get(0);
            Object a = null;
            boolean AisNegative = false;

            switch (firstChild) {
                case sym.CONSTANT:
                    setValidNumber(node.getChildren().get(0).getValue().value.toString(), node.getChildren().get(0),
                            type, false);
                    a = node.getChildren().get(0).getValue().value;
                    break;
                case sym.PLUS:
                case sym.MUL:
                case sym.DIVIDE:
                case sym.MINUS:
                    if (node.getChildren().get(0).getChildren().size() > 0) {
                        aritmetica(node.getChildren().get(0), type, table);
                        if (node.getChildren().get(0).getValue().sym == sym.CONSTANT) {
                            a = node.getChildren().get(0).getValue().value;
                        }
                    } else {
                        String error = "Error en la linea " + (node.getChildren().get(0).getValue().right + 1)
                                + ", columna " + node.getChildren().get(0).getValue().left + " en el token "
                                + node.getChildren().get(0).getValue().value
                                + ": Valor en expresion aritmetica no valida\n";
                        System.err.println(error);
                        errores += error;
                    }
                    break;
                case -1:
                    if (node.getChildren().get(0).getChildren().get(0).equals("-")) {
                        setValidNumber(node.getChildren().get(0).getChildren().get(1).getValue().value.toString(),
                                node.getChildren().get(0), type, false);
                        node.getChildren().get(0).setSym(sym.CONSTANT);
                        node.getChildren().get(0).deleteChildren();
                        a = node.getChildren().get(0).getValue().value;
                        AisNegative = true;
                    } else {
                        String error = "Error en la linea "
                                + (node.getChildren().get(0).getChildren().get(0).getValue().right + 1) + ", columna "
                                + node.getChildren().get(0).getChildren().get(0).getValue().left + " en el token "
                                + node.getChildren().get(0).getChildren().get(0).getValue().value
                                + ": Valor en expresion aritmetica no valida\n";
                        System.err.println(error);
                        errores += error;
                    }
                    break;
                case sym.IDENTIFIER:
                    /*
                     * TableRow secondResult = table.search(second.getValue().value.toString()); if
                     * (secondResult != null) { //Aquí le asigna a x el valor de b, virificando si
                     * son del mismo tipo if (firstResult.type.equals(secondResult.type)) {
                     * firstResult.value = secondResult.value; } else { //La segunda variable no es
                     * del mismo tipo String error = "Error en la linea " + (first.getValue().right
                     * + 1) + ", columna " + first.getValue().left + " en el token " +
                     * first.getValue().value + ": Varibales son de diferente tipo\n";
                     * System.err.println(error); errores += error; } } else { //La segunda variable
                     * no existe String error = "Error en la linea " + (second.getValue().right + 1)
                     * + ", columna " + second.getValue().left + " en el token " +
                     * second.getValue().value + ": Variable no ha sido declarada\n";
                     * System.err.println(error); errores += error; } break;
                     * 
                     */

                    // Aqui es donde entra cuando hacemos int c = a + 2 y a no existe
                    TableRow varExists = table.search(fChild.getValue().value.toString());

                    if (varExists != null) {
                        System.out.println("varExists: " + varExists.id);
                        System.out.println("Existe");
                        break;
                    } else {
                        String error = "Error en la linea " + (node.getChildren().get(0).getValue().right + 1)
                                + ", columna " + node.getChildren().get(0).getValue().left + " en el token "
                                + node.getChildren().get(0).getValue().value + ": la variable no existe\n";
                        System.err.println(error);
                        errores += error;
                        break;
                    }

                    // break;
                default:
                    String error = "Error en la linea " + (node.getChildren().get(0).getValue().right + 1)
                            + ", columna " + node.getChildren().get(0).getValue().left + " en el token "
                            + node.getChildren().get(0).getValue().value
                            + ": Valor en expresion aritmetica no valida\n";
                    System.err.println(error);
                    errores += error;
                    if (node.getValue().sym == sym.PLUS || node.getValue().sym == sym.MINUS) {
                        setValidNumber("0", node.getChildren().get(0), type, false);
                    } else {
                        setValidNumber("1", node.getChildren().get(0), type, false);
                    }
                    node.getChildren().get(0).setSym(sym.CONSTANT);
                    node.getChildren().get(0).deleteChildren();
                    a = node.getChildren().get(0).getValue().value;
                    break;
            }

            int secondChild = node.getChildren().get(1).getValue().sym;
            Object b = null;
            boolean BisNegative = false;

            switch (secondChild) {
                case sym.CONSTANT:
                    setValidNumber(node.getChildren().get(1).getValue().value.toString(), node.getChildren().get(1),
                            type, false);
                    b = node.getChildren().get(1).getValue().value;
                    break;
                case sym.PLUS:
                case sym.MUL:
                case sym.DIVIDE:
                case sym.MINUS:
                    if (node.getChildren().get(1).getChildren().size() > 0) {
                        aritmetica(node.getChildren().get(1), type, table);
                        if (node.getChildren().get(1).getValue().sym == sym.CONSTANT) {
                            b = node.getChildren().get(1).getValue().value;
                        }
                    } else {
                        String error = "Error en la linea " + (node.getChildren().get(1).getValue().right + 1)
                                + ", columna " + node.getChildren().get(1).getValue().left + " en el token "
                                + node.getChildren().get(1).getValue().value
                                + ": Valor en expresion aritmetica no valida\n";
                        System.err.println(error);
                        errores += error;
                    }
                    break;
                case -1:
                    if (node.getChildren().get(1).getChildren().get(0).equals("-")) {
                        setValidNumber(node.getChildren().get(1).getChildren().get(1).getValue().value.toString(),
                                node.getChildren().get(1), type, false);
                        node.getChildren().get(1).setSym(sym.CONSTANT);
                        node.getChildren().get(1).deleteChildren();
                        b = node.getChildren().get(1).getValue().value;
                        BisNegative = true;
                    } else {
                        String error = "Error en la linea "
                                + (node.getChildren().get(1).getChildren().get(0).getValue().right + 1) + ", columna "
                                + node.getChildren().get(1).getChildren().get(0).getValue().left + " en el token "
                                + node.getChildren().get(1).getChildren().get(0).getValue().value
                                + ": Valor en expresion aritmetica no valida\n";
                        System.err.println(error);
                        errores += error;
                    }
                    break;
                case sym.IDENTIFIER:
                    break;
                default:
                    String error = "Error en la linea " + (node.getChildren().get(1).getValue().right + 1)
                            + ", columna " + node.getChildren().get(1).getValue().left + " en el token "
                            + node.getChildren().get(1).getValue().value
                            + ": Valor en expresion aritmetica no valida\n";
                    System.err.println(error);
                    errores += error;
                    if (node.getValue().sym == sym.PLUS || node.getValue().sym == sym.MINUS) {
                        setValidNumber("0", node.getChildren().get(1), type, false);
                    } else {
                        setValidNumber("1", node.getChildren().get(1), type, false);
                    }
                    node.getChildren().get(1).setSym(sym.CONSTANT);
                    node.getChildren().get(1).deleteChildren();
                    b = node.getChildren().get(1).getValue().value;
                    break;
            }

            if (a != null && b != null) {
                Double A = Double.parseDouble(a.toString());
                if (AisNegative) {
                    A = A * -1;
                }
                Double B = Double.parseDouble(b.toString());
                if (BisNegative) {
                    B = B * -1;
                }

                String res = "";
                switch (symbol) {
                    case sym.PLUS:
                        res = Double.toString(A + B);
                        break;
                    case sym.MUL:
                        res = Double.toString(A * B);
                        break;
                    case sym.DIVIDE:
                        res = Double.toString(A / B);
                        break;
                    case sym.MINUS:
                        res = Double.toString(A - B);
                        break;
                }
                if (res.contains("-")) {
                    res = res.replace("-", "");
                    if (setValidNumber(res, node, type, true)) {
                        node.setSym(sym.CONSTANT);
                        node.deleteChildren();
                    }
                } else if (setValidNumber(res, node, type, false)) {
                    node.setSym(sym.CONSTANT);
                    node.deleteChildren();
                }
            }
        }
    }

    public static boolean setValidNumber(String value, MiArbolito node, String type, boolean negative) {
        Double ret;
        if (value.matches("[0-9.]*")) {
            ret = Double.parseDouble(value);
        } else {
            // Aqui es donde hace los chars en int, los pasa a ascii
            Integer ascii = (int) value.replace("\'", "").charAt(0);
            ret = ascii.doubleValue();
        }
        node.deleteChildren();
        if (negative) {
            ret = ret * -1;
        }
        switch (type) {
            case "short":
                if (ret.shortValue() >= -32768 && ret.shortValue() <= 32767) {
                    node.setValue(ret.shortValue());
                    return true;
                }
                break;
            case "long":
                node.setValue(ret.longValue());
                return true;
            case "int":
            case "char":
                node.setValue(ret.intValue());
                return true;
            case "float":
                node.setValue(ret.floatValue());
                return true;
            case "double":
                node.setValue(ret);
                return true;
        }
        return false;
    }

    public static String[] arrayParse(TableRow row) {
        String type = "";
        type = row.type.replace("array(", "");
        type = type.replace(")", "");
        String response[] = type.split(", ");
        return response;
    }

    public static void Intermedio(MiArbolito parent_node, Table table) {
        ArrayList<MiArbolito> children = parent_node.getChildren();

        for (MiArbolito child : children) {

            if (child.getValue().value.equals("=")) {
                Table child_table = new Table(table);
                table.addChild(child_table);

                recorrerFinal(child, child_table);
            } else if (child.getValue().value.equals("postfix_expression")) {
                ArrayList<MiArbolito> hijos = child.getChildren();

                // System.out.println("\n ////////////// ");

                // for (MiArbolito nodoHijo : hijos) {
                //     System.out.println(nodoHijo.getValue().value);

                // }

                // System.out.println("\n ////////////// ");

                MiArbolito tipoPostFix = hijos.get(1);
                MiArbolito nodoPrint = hijos.get(2);

                if (tipoPostFix.getValue().value.equals("printf")) {
                    if (nodoPrint.getValue().value.equals("expression")) { // es un print con variable

                        String mensaje = nodoPrint.getChildren().get(0).getValue().value + "";
                        String variable = nodoPrint.getChildren().get(1).getValue().value + "";

                        String nombreMensaje = "_msg" + (tablamensajes.rows.size() + 1);

                        tablamensajes.addMensaje(new Mensaje(mensaje, variable, nombreMensaje));

                        TablaCuadruplos.addRow("PRINT", nombreMensaje, variable, "");

                    } else { // es un print normal

                        String mensaje = nodoPrint.getValue().value + "";

                        String nombreMensaje = "_msg" + (tablamensajes.rows.size() + 1);

                        tablamensajes.addMensaje(new Mensaje(mensaje, "", nombreMensaje));

                        TablaCuadruplos.addRow("PRINTF", nombreMensaje, "", "");
                    }

                } else if (tipoPostFix.getValue().value.equals("scanf")) {
                    MiArbolito primerArgumentoString = nodoPrint.getChildren().get(0);
                    MiArbolito unaryExpression = nodoPrint.getChildren().get(1);

                    MiArbolito ampersand = unaryExpression.getChildren().get(0);
                    MiArbolito variable = unaryExpression.getChildren().get(1);
    
                    String puntero = ampersand.getValue().value + "" + variable.getValue().value;

                    TablaCuadruplos.addRow("SCANF", primerArgumentoString.getValue().value + "", puntero, "");

                }

            } else { 
                Intermedio(child, table);
            }
        }
    }

    public static String newTemporal() {
        String temp = "t" + String.valueOf(CantTemporales);
        CantTemporales++;
        return temp;
    }

    public static void recorrerFinal(MiArbolito node, Table table) {

        if (node.getChildren().size() == 2) {

            MiArbolito second = node.getChildren().get(1);
            MiArbolito primero = node.getChildren().get(0);

            int secondChild = second.getValue().sym;
            int firstChild = primero.getValue().sym;

            // revision de punteros

            if (second.getValue().value.equals("unary_expression")) { // si el nodo a la derecha es un puntero, realizar
                                                                      // operacion distinta
                // String newTemp = newTemporal();

                MiArbolito ampersand = second.getChildren().get(0);
                MiArbolito variable = second.getChildren().get(1);

                String puntero = ampersand.getValue().value + "" + variable.getValue().value;

                TablaCuadruplos.addRow("=", puntero, "", "_" + primero.getValue().value + "");
            } else {
                switch (firstChild) {
                    case sym.PLUS:
                    case sym.MUL:
                    case sym.DIVIDE:
                    case sym.MINUS:
                        switch (secondChild) {
                            case sym.PLUS:
                            case sym.MUL:
                            case sym.DIVIDE:
                            case sym.MINUS:
                                recorrerFinal(primero, table);
                                recorrerFinal(second, table);
                                break;
                            case -1:

                                break;

                            default:
                            case sym.IDENTIFIER:
                                // addtoQuad(node, table);
                                recorrerFinal(primero, table);
                                break;
                        }

                        break;
                    case -1:

                        break;
                    case sym.IDENTIFIER:
                    default:

                        switch (secondChild) {
                            case sym.PLUS:
                            case sym.MUL:
                            case sym.DIVIDE:
                            case sym.MINUS:
                                // recorrerFinal(primero, table);
                                recorrerFinal(second, table);
                                break;
                            case -1:

                                break;

                            default:
                            case sym.IDENTIFIER:
                                addtoQuad(node, table);
                                break;
                        }

                        break;

                }
            }

            // second.setParent(node);

            // System.out.println("Sym: " + secondChild + " Left: " +
            // node.getChildren().get(0).getValue().value
            // + " , DER: " + second.getValue().value);

            // System.out.println("Node: " + node.getValue().value);

            // System.out.println("Fath: " + node.getParent().getValue().value);
            // System.out.println("Hij1: " + node.getChildren().get(0).getValue().value);
            // System.out.println("Hij2: " + node.getChildren().get(1).getValue().value);
            // System.out.println("");

        }

    }

    public static void addtoQuad(MiArbolito node, Table table) {

        // System.out.println("\n + ///////////////////// \n Nodo: " +
        // node.getValue().value);
        // System.out.println("Padre mio: " + node.getParent().getValue().value);
        // System.out.println("Cant hijos mios: " + node.getChildren().size());
        // System.out.println("Padre de mi padre: " +
        // node.getParent().getParent().getValue().value + "\n");

        String father = node.getParent().getValue().value.toString();
        String nodeString = node.getValue().value.toString();

        int hijos = node.getChildren().size();
        boolean isGarbageNode = true;

        if (hijos == 2) {
            isGarbageNode = false;
        }

        if (

        (father.equals("additive_expression") || father.equals("shift_expression")
                || father.equals("relational_expression") || father.equals("equality_expression")
                || father.equals("and_expression") || father.equals("inclusive_or_expression")
                || father.equals("logical_and_expression") || father.equals("conditional_expression")
                || father.equals("logical_or_expression")
        // revisar si es un nodo restante del arbol, si lo es, subir su padre y asi
        // sucesivamente

        ) && isGarbageNode) {
            node.getParent().setLugar(node.getLugar());
            addtoQuad(node.getParent(), table);
        } else if (nodeString.equals("conditional_expression")) {

            node.getParent().setLugar(node.getLugar());
            addtoQuad(node.getParent().getParent(), table);
        } else if (nodeString.equals("multiplicative_expression")) {

            node.getParent().setLugar(node.getLugar());
            addtoQuad(node.getParent().getParent(), table);
        } else {
            MiArbolito izq = node.getChildren().get(0);
            MiArbolito der = node.getChildren().get(1);

            MiArbolito padre = node.getParent();

            int secondChild = der.getValue().sym;
            int firstChild = izq.getValue().sym;

            boolean isUnary = checkUnaryNode(secondChild);
            boolean isUnaryFirst = checkUnaryNode(firstChild);

            // System.out.println(izq.getValue().value);
            // System.out.println(der.getValue().value);

            // System.out.println("");

            // System.out.println(isUnary);

            if (node.getValue().value.equals("=")) {

                // ya llego al tope, fin de recursion

                String op = node.getValue().value + "";

                if (der.getLugar().equals("")) {
                    der.setLugar(der.getValue().value + "");
                }

                // String newTemp = newTemporal();

                TablaCuadruplos.addRow(op, der.getLugar(), "_" + izq.getValue().value + "");

            } else if (!isUnary && !isUnaryFirst) {
                // este es el fondo del arbol, ninguno de los nodos hijos son operadores

                izq.setLugar(izq.getValue().value + "");
                der.setLugar(der.getValue().value + "");

                String newTemp = newTemporal();

                node.setLugar(newTemp);

                String op = node.getValue().value + "";

                TablaCuadruplos.addRow(op, izq.getLugar(), der.getLugar(), newTemp);

                addtoQuad(padre, table);

            } else {
                // subiendo el arbol

                if (isUnaryFirst && isUnary) {
                    // cuando ambos nodos son operadores.

                    // System.out.println("VVV Ambos ops VVv");
                    // System.out.println(
                    // "Op1: " + izq.getValue().value + " OP 2: " + der.getValue().value + "\n
                    // ^^^^^^^ \n");

                    if (der.getLugar().equals("") || izq.getLugar().equals("")) {
                        // ignorar
                    } else {

                        TableRowQuad ultimoCuad = TablaCuadruplos.rows.get(TablaCuadruplos.rows.size() - 1);

                        String arg1 = ultimoCuad.getArg1();
                        String arg2 = ultimoCuad.getArg2();
                        String op = ultimoCuad.getOp();
                        String res = ultimoCuad.getRes();

                        String opNodo = node.getValue().value + "";

                        // System.out.println("Ultimo CUAD -> Arg1: " + arg1 + " Arg2: " + arg2 + " OP:
                        // " + op);
                        // System.out.println("CUAD a agregar -> Arg1: " + izq.getLugar() + " Arg2: " +
                        // der.getLugar()
                        // + " OP: " + opNodo);

                        String izqLugar = izq.getLugar();
                        String derLugar = der.getLugar();

                        if (arg1.equals(izqLugar) && arg2.equals(derLugar) && op.equals(opNodo))

                        {

                            node.setLugar(res);

                            // System.out.println("SOY IGUAL");

                            // TablaCuadruplos.addRow(opNodo, izq.getLugar(), der.getLugar(), newTemp);

                            String father1 = node.getParent().getValue().value.toString();

                            if (father1.equals("multiplicative_expression") || father1.equals("additive_expression")) {
                                node.getParent().setLugar(node.getLugar());
                                addtoQuad(node.getParent(), table);
                            } else {
                                addtoQuad(padre, table);
                            }

                        } else {

                            String newTemp = newTemporal();
                            node.setLugar(newTemp);

                            TablaCuadruplos.addRow(opNodo, izq.getLugar(), der.getLugar(), newTemp);

                            String father1 = node.getParent().getValue().value.toString();

                            if (father1.equals("multiplicative_expression") || father1.equals("additive_expression")) {
                                node.getParent().setLugar(node.getLugar());
                                addtoQuad(node.getParent(), table);
                            } else {
                                addtoQuad(padre, table);
                            }
                        }

                    }

                } else if (isUnaryFirst) {
                    // el nodo izq es un op, que agarre el lugar
                    der.setLugar(der.getValue().value + "");

                    String opNodo = node.getValue().value + "";

                    TableRowQuad ultimoCuad = TablaCuadruplos.rows.get(TablaCuadruplos.rows.size() - 1);

                    String arg1 = ultimoCuad.arg1;
                    String arg2 = ultimoCuad.arg2;
                    String op = ultimoCuad.op;

                    String res = ultimoCuad.getRes();

                    // System.out.println("Ultimo CUAD -> Arg1: " + arg1 + " Arg2: " + arg2 + " OP:
                    // " + op);
                    // System.out.println("CUAD a agregar -> Arg1: " + izq.getLugar() + " Arg2: " +
                    // der.getLugar()
                    // + " OP: " + opNodo);

                    String izqLugar = izq.getLugar();
                    String derLugar = der.getLugar();

                    if (arg1.equals(izqLugar) && arg2.equals(derLugar) && op.equals(opNodo))

                    {

                        node.setLugar(res);

                        // System.out.println("SOY IGUAL");

                        // TablaCuadruplos.addRow(opNodo, izq.getLugar(), der.getLugar(), newTemp);

                        String father1 = node.getParent().getValue().value.toString();

                        if (father1.equals("multiplicative_expression") || father1.equals("additive_expression")) {
                            node.getParent().setLugar(node.getLugar());
                            addtoQuad(node.getParent(), table);
                        } else {
                            addtoQuad(padre, table);
                        }

                    } else {

                        String newTemp = newTemporal();
                        node.setLugar(newTemp);

                        TablaCuadruplos.addRow(opNodo, izq.getLugar(), der.getLugar(), newTemp);

                        String father1 = node.getParent().getValue().value.toString();

                        if (father1.equals("multiplicative_expression") || father1.equals("additive_expression")) {
                            node.getParent().setLugar(node.getLugar());
                            addtoQuad(node.getParent(), table);
                        } else {
                            addtoQuad(padre, table);
                        }
                    }

                } else if (isUnary) {
                    // el nodo derecho es un op
                    izq.setLugar(izq.getValue().value + "");

                    String opNodo = node.getValue().value + "";

                    TableRowQuad ultimoCuad = TablaCuadruplos.rows.get(TablaCuadruplos.rows.size() - 1);

                    String arg1 = ultimoCuad.arg1;
                    String arg2 = ultimoCuad.arg2;
                    String op = ultimoCuad.op;
                    String res = ultimoCuad.getRes();

                    // System.out.println("Ultimo CUAD -> Arg1: " + arg1 + " Arg2: " + arg2 + " OP:
                    // " + op);
                    // System.out.println("CUAD a agregar -> Arg1: " + izq.getLugar() + " Arg2: " +
                    // der.getLugar()
                    // + " OP: " + opNodo);

                    String izqLugar = izq.getLugar();
                    String derLugar = der.getLugar();

                    if (arg1.equals(izqLugar) && arg2.equals(derLugar) && op.equals(opNodo))

                    {

                        node.setLugar(res);

                        // System.out.println("SOY IGUAL");

                        // TablaCuadruplos.addRow(opNodo, izq.getLugar(), der.getLugar(), newTemp);

                        String father1 = node.getParent().getValue().value.toString();

                        if (father1.equals("multiplicative_expression") || father1.equals("additive_expression")) {
                            node.getParent().setLugar(node.getLugar());
                            addtoQuad(node.getParent(), table);
                        } else {
                            addtoQuad(padre, table);
                        }

                    } else {

                        String newTemp = newTemporal();
                        node.setLugar(newTemp);

                        TablaCuadruplos.addRow(opNodo, izq.getLugar(), der.getLugar(), newTemp);

                        String father1 = node.getParent().getValue().value.toString();

                        if (father1.equals("multiplicative_expression") || father1.equals("additive_expression")) {
                            node.getParent().setLugar(node.getLugar());
                            addtoQuad(node.getParent(), table);
                        } else {
                            addtoQuad(padre, table);
                        }
                    }

                }

            }
        }

    }

    public static boolean checkUnaryNode(int secondChild) {

        boolean isUnary = false;

        switch (secondChild) {
            case sym.PLUS:
            case sym.MUL:
            case sym.DIVIDE:
            case sym.MINUS:
                isUnary = true;
                break;
            case -1:

                break;
            case sym.IDENTIFIER:
                break;
            default:
                break;
        }

        return isUnary;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        // <editor-fold defaultstate="collapsed" desc=" Look and feel setting code
        // (optional) ">
        /*
         * If Nimbus (introduced in Java SE 6) is not available, stay with the default
         * look and feel. For details see
         * http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Windows".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(App.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(App.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(App.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(App.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        // </editor-fold>
        // sym s = new sym();
        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new App().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JButton jb_RUN;
    private javax.swing.JButton jb_clear;
    private javax.swing.JButton jb_compile;
    private javax.swing.JButton jb_load;
    private javax.swing.JButton jb_save;
    private javax.swing.JButton jb_save_as;
    private javax.swing.JTextArea ta_code;
    private javax.swing.JTextArea ta_result;
    // End of variables declaration//GEN-END:variables
    File input_C;
    static String errores;
    static Table globalVariables;
    static String funcType;
    static String funName;

}
